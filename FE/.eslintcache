[{"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/index.js":"1","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/App.js":"2","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/reportWebVitals.js":"3","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/header.component.jsx":"4","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/startGame.component.jsx":"5","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/joinGame.component.jsx":"6","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/services/main.service.jsx":"7","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/piece.component.jsx":"8","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/game/game.component.jsx":"9","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/game/canvas.component.jsx":"10","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/generator/piece-generator.component.jsx":"11","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/generator/random-generator.jsx":"12","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/generator/piece-generator.jsx":"13","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/pieces.component.jsx":"14","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/generator/util-functions.jsx":"15","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/services/server.service.jsx":"16"},{"size":546,"mtime":1608644977766,"results":"17","hashOfConfig":"18"},{"size":1302,"mtime":1620346232714,"results":"19","hashOfConfig":"18"},{"size":362,"mtime":1608644977766,"results":"20","hashOfConfig":"18"},{"size":945,"mtime":1620385691849,"results":"21","hashOfConfig":"18"},{"size":1438,"mtime":1615518914937,"results":"22","hashOfConfig":"18"},{"size":1408,"mtime":1615510818642,"results":"23","hashOfConfig":"18"},{"size":954,"mtime":1617560737947,"results":"24","hashOfConfig":"18"},{"size":1206,"mtime":1620388532240,"results":"25","hashOfConfig":"18"},{"size":10819,"mtime":1619792401842,"results":"26","hashOfConfig":"18"},{"size":634,"mtime":1619130633405,"results":"27","hashOfConfig":"18"},{"size":4340,"mtime":1620342205859,"results":"28","hashOfConfig":"18"},{"size":820,"mtime":1620342409732,"results":"29","hashOfConfig":"18"},{"size":4277,"mtime":1620388503124,"results":"30","hashOfConfig":"18"},{"size":1174,"mtime":1620373843156,"results":"31","hashOfConfig":"18"},{"size":718,"mtime":1620395140087,"results":"32","hashOfConfig":"18"},{"size":235,"mtime":1620385249228,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"2zlue",{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"51","messages":"52","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"36"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"36"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"36"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"64","messages":"65","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"36"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/index.js",[],["71","72"],"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/App.js",[],"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/reportWebVitals.js",[],"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/header.component.jsx",["73"],"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/startGame.component.jsx",[],"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/joinGame.component.jsx",[],"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/services/main.service.jsx",[],"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/piece.component.jsx",["74","75","76"],"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/game/game.component.jsx",["77","78","79","80","81","82","83"],"import React, { Component } from 'react'\nimport mainService from '../services/main.service';\nimport Canvas from './canvas.component';\nimport PieceComponent from '../components/piece.component';\nimport PieceGeneratorComponent from '../generator/piece-generator.component';\n\nclass GameComponent extends Component {\n\n\n\n    constructor(props) {\n        super(props)\n        this.state = {\n            gameId: JSON.parse(localStorage.getItem(\"auth\")).gameId,\n            me: JSON.parse(localStorage.getItem(\"auth\")).player,\n            inviteLink: \"http://localhost:3000/joingame/\" + JSON.parse(localStorage.getItem(\"auth\")).gameId,\n\n            //game\n            player1: {},\n            player2: {},\n            boardData: {}, // data from server\n            boardView: {}, // symbol, playertype\n            width: 16,\n            height: 16,\n            turn: \"P1\",\n            round: 0,\n            isInited: false,\n\n            //selection\n            selectedField: {},\n            possibleMoves: [],\n\n            //pieces\n            pieces: {},\n\n\n\n            //consts\n            squareSize: 60,\n            boardTopx: 30,\n            boardTopy: 30,\n            updateInterval: 1500\n        }\n        this.updateGameData();\n        this.loadBoard();\n        this.selectField = this.selectField.bind(this);\n        this.clickOnCanvas = this.clickOnCanvas.bind(this);\n        this.drawMethod = this.drawMethod.bind(this);\n        this.play = this.play.bind(this);\n\n        const loadTimer = setInterval(() => {\n            this.updateGameData();\n        }, this.state.updateInterval);\n    }\n\n    componentDidMount() {\n\n    }\n\n    updateGameData() {\n        const { gameId, turn } = this.state;\n        mainService.getGameData(gameId).then((res) => {\n            this.setState({ player1: res.data.player1, player2: res.data.player2, turn: res.data.turn, round: res.data.round });\n\n            //when other player made his turn\n            if (turn !== res.data.turn) {\n\n                this.loadBoard();\n            }\n\n            //check game end ?\n        });\n    }\n\n\n\n    loadBoard() {\n        const { gameId, isInited, squareSize } = this.state;\n        mainService.getBoard(gameId).then((res) => {\n            let bv = res.data.board;\n            //console.log(bv);\n            for (let i = 0; i < bv.length; i++) {\n                for (let j = 0; j < bv[0].length; j++) {\n                    if (res.data.board[i][j] === null) {\n                        bv[i][j] = {\n                            symbol: \"\",\n                            owner: \"\",\n                            possibleMoves: []\n                        };\n                    } else {\n                        bv[i][j] = {\n                            symbol: bv[i][j].symbol,\n                            owner: bv[i][j].owner,\n                            possibleMoves: bv[i][j].possibleMoves\n                        };\n                    }\n                }\n            }\n            if (!isInited) {\n                var pieces = [];\n                // fill pieces canvas buffer\n                for (let i = 0; i < bv.length; i++) {\n                    for (let j = 0; j < bv[0].length; j++) {\n                        if (bv[i][j].symbol !== \"\" && pieces[bv[i][j].symbol] === undefined) {\n                            pieces[bv[i][j].symbol] = PieceGeneratorComponent.drawPieceCanvas(squareSize * 0.8, squareSize * 0.95, bv[i][j].symbol, bv[i][j].owner);\n                        }\n                    }\n                }\n                //console.log(\"size\", pieces);\n                this.setState({ pieces: pieces, isInited: true, boardData: res.data, boardView: bv, width: bv[0].length, height: bv.length });\n            }\n            this.setState({ boardData: res.data, boardView: bv, width: bv[0].length, height: bv.length });\n\n        });\n    }\n\n    selectField(x, y) {\n        const { boardView, selectedField, me, turn, possibleMoves } = this.state;\n        const isPlayerTurn = me === turn;\n        const isEmptyField = boardView[y][x].symbol === \"\";\n        const sthSelected = JSON.stringify(selectedField) !== \"{}\";\n\n        if (sthSelected) {\n            const isAlreadySelected = selectedField.x === x && selectedField.y === y;\n            const isPossibleMove = possibleMoves.some(move => move.x === x && move.y === y);\n            const isOwnSelected = me == boardView[selectedField.y][selectedField.x].owner;\n\n            // move,unselect, another select ?\n\n            if (isAlreadySelected) {\n                // unselect\n                this.setState({\n                    possibleMoves: [],\n                    selectedField: {}\n                });\n            } else if (isOwnSelected && isPossibleMove && isPlayerTurn) {\n                // move\n                const draw = { fromPos: { x: selectedField.x, y: selectedField.y }, toPos: { x: x, y: y } }\n                this.play(draw);\n            } else if (isEmptyField) {\n                // unselect\n                this.setState({\n                    possibleMoves: [],\n                    selectedField: {}\n                });\n            } else {\n                // select new position\n                this.setState({\n                    possibleMoves: boardView[y][x].possibleMoves,\n                    selectedField: { x: x, y: y }\n                });\n            }\n        } else {\n            if (!isEmptyField) {\n                // select new position\n                this.setState({\n                    possibleMoves: boardView[y][x].possibleMoves,\n                    selectedField: { x: x, y: y }\n                });\n            }\n        }\n    }\n\n    play(draw) {\n        const { gameId, turn } = this.state;\n        mainService.play(gameId, draw).then((res) => {\n            console.log(\"played\", turn);\n            const nextTurn = (turn === \"P1\") ? \"P2\" : \"P1\";\n            this.setState({\n                possibleMoves: [],\n                selectedField: {},\n                turn: nextTurn\n            });\n\n            this.updateGameData();\n            this.loadBoard();\n        });\n    }\n\n\n\n\n    clickOnCanvas(event) {\n        const { squareSize, boardTopy, boardTopx } = this.state;\n        const rect = event.target.getBoundingClientRect();\n        const x = event.clientX - rect.left - boardTopx;\n        const y = event.clientY - rect.top - boardTopy;\n        //console.log(\"x: \" + x + \" y: \" + y);\n        this.selectField((x - x % squareSize) / (squareSize), (y - y % squareSize) / (squareSize));\n    }\n\n    drawMethod() {\n        const { width, height, squareSize, boardView, possibleMoves, boardTopy, boardTopx, selectedField, me, pieces } = this.state;\n\n\n        const draw = (ctx, frameCount) => {\n\n            if (boardView) {\n\n                ctx.canvas.width = squareSize * (width + 1)\n                ctx.canvas.height = squareSize * (height + 1)\n\n                //draw board\n                for (let i = 0; i < width; i++) {\n                    for (let j = 0; j < height; j++) {\n                        ctx.fillStyle = ((i + j) % 2 == 0) ? \"#D2B48C\" : \"PeachPuff\";\n                        let xOffset = boardTopx + j * squareSize;\n                        let yOffset = boardTopy + i * squareSize;\n                        ctx.fillRect(xOffset, yOffset, squareSize, squareSize);\n                    }\n                }\n                if (JSON.stringify(selectedField) !== \"{}\") {\n                    // draw moves\n                    ctx.globalAlpha = 0.45;\n                    ctx.fillStyle = (me === boardView[selectedField.y][selectedField.x].owner) ? \"lightgreen\" : \"red\";\n                    for (let k = 0; k < possibleMoves.length; k++) {\n                        let xOffset = boardTopx + possibleMoves[k].x * squareSize;\n                        let yOffset = boardTopy + possibleMoves[k].y * squareSize;\n\n                        ctx.fillRect(xOffset, yOffset, squareSize, squareSize);\n                    }\n\n                    //draw selected\n                    ctx.fillStyle = (me === boardView[selectedField.y][selectedField.x].owner) ? \"green\" : \"darkred\";\n                    ctx.fillRect(boardTopx + selectedField.x * squareSize, boardTopy + selectedField.y * squareSize, squareSize, squareSize);\n                    ctx.globalAlpha = 1;\n                }\n\n                // draw pieces\n                if (boardView[0]) {\n                    ctx.fillStyle = \"black\";\n                    ctx.font = \"20px Arial\";\n                    for (let i = 0; i < width; i++) {\n                        for (let j = 0; j < height; j++) {\n                            if (boardView[j][i].symbol !== \"\") {\n\n                                let xOffset = boardTopx + (i + 0.115) * squareSize;\n                                let yOffset = boardTopy + (j + 0.05) * squareSize;\n                                if (pieces.length !== 0) {\n                                    //  console.log(pieces);\n                                    ctx.drawImage(pieces[boardView[j][i].symbol], xOffset, yOffset);\n                                }\n                                //}\n\n\n                            }\n                        }\n                    }\n                }\n\n                // draw the border around the chessboard\n                ctx.strokeStyle = \"black\";\n                ctx.strokeRect(boardTopx, boardTopy, squareSize * width, squareSize * height)\n\n            }\n        }\n        return draw;\n    }\n\n    drawPiece(pieceCode, player) {\n        if (player === \"P1\") {\n            //return \"♖\";\n\n        }\n        return pieceCode;\n        //        return \"♜\";\n    }\n\n    drawGameText() {\n        const { me, turn } = this.state;\n        if (me === turn) {\n            return \"Your turn!\";\n        }\n        return \"Wait for opponents turn...\";\n    }\n\n\n    render() {\n        const { inviteLink, player1, player2, boardView, selectedField, turn, me, round } = this.state;\n        var piece = \"\";\n        if (boardView[0] && selectedField.x) {\n            piece = boardView[selectedField.y][selectedField.x];\n            //console.log(piece);\n        }\n\n\n        // TODO: aufteilen in GameData und PieceData ?\n        return (\n\n            <div>\n                {/* <img id=\"scream\" width=\"220\" height=\"277\" src=\"https://filesamples.com/samples/image/svg/sample_640%C3%97426.svg\" alt=\"The Scream\"></img> */}\n\n\n                <div>            {this.drawGameText()}</div>\n                <Canvas draw={this.drawMethod()} onClick={this.clickOnCanvas} />\n                {/* <div>{piece.symbol} {\" \"}{piece.owner}</div>*/}\n                <div>\n                    {inviteLink}\n                </div>\n                <div>\n                    Player1: {player1 && player1.name} {player2 && <>Player2: {player2.name}</>} {\" round:\"}{round}\n                </div>\n\n            </div >\n        )\n    }\n}\n\nexport default GameComponent","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/game/canvas.component.jsx",[],"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/generator/piece-generator.component.jsx",["84","85"],"import React, { Component } from 'react'\nimport RandomGenerator from './random-generator';\n\nclass PieceGeneratorComponent extends Component {\n\n    static gen;\n    static width = 600;\n    static height = 600;\n\n\n\n\n\n\n\n    // static nextRand() {\n    //     var hi = this.seed / (2147483647 / 48271);\n    //     var lo = this.seed % (2147483647 / 48271);\n    //     var test = 48271 * lo - (2147483647 % 48271) * hi;\n    //     if (test > 0) {\n    //         this.seed = test;\n    //     } else {\n    //         this.seed = test + 2147483647;\n    //     }\n    //     return this.seed * (1.0 / 2147483647);\n    // }\n\n\n\n    // static drawPolygon() {\n\n    //     var pointNumber = this.randNumOfRange(3, 5);\n    //     console.log(\"pointNumber=\" + pointNumber)\n    //     //console.log(Math.floor(this.nextRand() * 16777215).toString(16));\n    //     var color = \"#\" + Math.floor(this.nextRand() * 16777215).toString(16);\n\n    //     var pts = \"\";\n    //     var ptsMirror = \"\";\n    //     for (var i = 0; i < pointNumber; i++) {\n    //         var x = this.randNumOfRange(0, this.width);\n    //         var y = this.randNumOfRange(0, this.height);\n    //         pts += x + \",\" + y + \" \";\n    //         var x2 = this.width - x;\n    //         ptsMirror += x2 + \",\" + y + \" \";\n    //         //  console.log(i);\n    //     }\n\n    //     return <><polygon points={pts} fill={color} />\n    //         <polygon points={ptsMirror} fill={color} /></>;\n    // }\n\n\n    // static drawPiece(width, height, seed, owner) {\n    //     this.seed = seed;\n    //     this.width = width;\n    //     this.height = height;\n\n    //     return (\n    //         <>\n    //             <svg height={this.height} width={this.width}>\n    //                 {this.drawPolygon()}\n    //                 {this.drawPolygon()}\n    //                 {this.drawPolygon()}\n    //                 {this.drawPolygon()}\n    //                 {this.drawPolygon()}\n    //             </svg>\n    //         </>\n    //     )\n    // }\n\n\n\n    static drawPolygonCanvas(c2) {\n        // TODO:     var shape1 = new Path2D();\n        // circle.arc(100, 35, 25, 0, 2 * Math.PI);\n\n        // ctx.stroke(rectangle);\n        // ctx.fill(circle);\n\n\n        var pointNumber = this.randNumOfRange(3, 10);\n        //console.log(\"pointNumber=\" + pointNumber)\n        var r = Math.floor(this.random() * 255).toString(16);\n        var g = Math.floor(this.random() * 255).toString(16);\n        var b = Math.floor(this.random() * 255).toString(16);\n        var color = \"#\" + r + g + b;\n\n\n        // var color = \"#\" + Math.floor(this.random() * 255).toString(2);\n        // 16 777 216\n        console.log(color);\n\n        var points = [];\n        for (var i = 0; i < pointNumber; i++) {\n            var x = this.randNumOfRange(0, this.width);\n            var y = this.randNumOfRange(0, this.height);\n            points.push({ x: x, y: y });\n        }\n\n\n        c2.fillStyle = color;\n        c2.beginPath();\n        for (var i = 0; i < points.length; i++) {\n            if (i === 0) {\n                c2.moveTo(points[i].x, points[i].y);\n            } else {\n                c2.lineTo(points[i].x, points[i].y);\n            }\n        }\n        c2.closePath();\n        c2.fill();\n\n        c2.fillStyle = color;\n        c2.beginPath();\n\n        for (var j = 0; j < points.length; j++) {\n            var x2 = this.width - points[j].x;\n            if (j === 0) {\n                c2.moveTo(x2, points[j].y);\n            } else {\n                c2.lineTo(x2, points[j].y);\n            }\n        }\n        c2.closePath();\n        c2.fill();\n    }\n\n\n    static random() {\n        return this.gen.random();\n    }\n\n    static randNumOfRange(a, b) {\n        return this.gen.randNumOfRange(a, b);\n    }\n\n\n\n\n    static drawPieceCanvas(width, height, seedstr, owner) {\n        this.gen = new RandomGenerator(seedstr);\n\n        this.width = width;\n        this.height = height;\n\n        var canvas2 = document.createElement('canvas');\n        canvas2.width = width;\n        canvas2.height = height;\n        var context2 = canvas2.getContext('2d');\n        this.drawPolygonCanvas(context2);\n        this.drawPolygonCanvas(context2);\n        this.drawPolygonCanvas(context2);\n        this.drawPolygonCanvas(context2);\n\n        return (\n            canvas2\n        );\n    }\n\n\n\n\n}\n\nexport default PieceGeneratorComponent","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/generator/random-generator.jsx",["86"],"import React, { Component } from 'react'\n\nclass RandomGenerator extends Component {\n\n\n    constructor(str) {\n        super();\n        this.tempSeed = this.hash(str);\n        // console.log(\"str=\", str, \"seed=\", this.tempSeed);\n    }\n\n    random() {\n        var x = Math.sin(this.tempSeed) * 10000;\n        this.tempSeed = Math.sin(this.tempSeed);\n        return x - Math.floor(x);\n    }\n\n    randNumOfRange(a, b) {\n\n        return Math.round(this.random() * (b - a) + a);\n    }\n\n\n    hash(str) {\n        var hash = 0, i, chr;\n        if (str.length === 0) return hash;\n        for (i = 0; i < str.length; i++) {\n            chr = str.charCodeAt(i);\n            hash = ((hash << 5) - hash) + chr;\n            hash |= 0; // Convert to 32bit integer\n        }\n        return hash;\n    };\n\n\n}\n\nexport default RandomGenerator","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/generator/piece-generator.jsx",["87"],"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/pieces.component.jsx",["88","89"],"import React, { Component } from 'react'\nimport Canvas from '../game/canvas.component';\nimport PieceGenerator from '../generator/piece-generator';\nimport RandomGenerator from '../generator/random-generator';\nimport UtilFunctions from '../generator/random-generator';\n\nclass PiecesComponent extends Component {\n\n    constructor(props) {\n\n        super(props);\n        this.state = {\n            width: 50,\n            height: 60,\n            pieces: []\n        }\n\n        for (var i = 0; i < 110; i++) {\n            var pg = new PieceGenerator(this.state.width, this.state.height, \"\" + Math.random());\n            this.state.pieces.push(pg.drawPieceCanvas(\"P1\"));\n        }\n\n    }\n\n    drawMethod(piece) {\n        const { width, height } = this.state;\n\n        const draw = (ctx, frameCount) => {\n            ctx.canvas.width = width\n            ctx.canvas.height = height\n            ctx.drawImage(piece, 0, 0);\n        }\n        return draw;\n    }\n\n    drawPieces() {\n        const { pieces } = this.state;\n        return pieces.map((p) => <Canvas draw={this.drawMethod(p)} />)\n    }\n\n    render() {\n        return this.drawPieces();\n    }\n}\n\nexport default PiecesComponent","/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/generator/util-functions.jsx",["90","91","92","93"],"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/services/server.service.jsx",[],{"ruleId":"94","replacedBy":"95"},{"ruleId":"96","replacedBy":"97"},{"ruleId":"98","severity":1,"message":"99","line":27,"column":31,"nodeType":"100","endLine":27,"endColumn":70},{"ruleId":"101","severity":1,"message":"102","line":4,"column":8,"nodeType":"103","messageId":"104","endLine":4,"endColumn":23},{"ruleId":"101","severity":1,"message":"105","line":5,"column":8,"nodeType":"103","messageId":"104","endLine":5,"endColumn":21},{"ruleId":"101","severity":1,"message":"106","line":38,"column":13,"nodeType":"103","messageId":"104","endLine":38,"endColumn":18},{"ruleId":"101","severity":1,"message":"107","line":4,"column":8,"nodeType":"103","messageId":"104","endLine":4,"endColumn":22},{"ruleId":"101","severity":1,"message":"108","line":51,"column":15,"nodeType":"103","messageId":"104","endLine":51,"endColumn":24},{"ruleId":"109","severity":1,"message":"110","line":126,"column":38,"nodeType":"111","messageId":"112","endLine":126,"endColumn":40},{"ruleId":"109","severity":1,"message":"110","line":206,"column":54,"nodeType":"111","messageId":"112","endLine":206,"endColumn":56},{"ruleId":"101","severity":1,"message":"113","line":279,"column":73,"nodeType":"103","messageId":"104","endLine":279,"endColumn":77},{"ruleId":"101","severity":1,"message":"114","line":279,"column":79,"nodeType":"103","messageId":"104","endLine":279,"endColumn":81},{"ruleId":"101","severity":1,"message":"115","line":282,"column":13,"nodeType":"103","messageId":"104","endLine":282,"endColumn":18},{"ruleId":"101","severity":1,"message":"116","line":1,"column":8,"nodeType":"103","messageId":"104","endLine":1,"endColumn":13},{"ruleId":"117","severity":1,"message":"118","line":103,"column":18,"nodeType":"103","messageId":"119","endLine":103,"endColumn":19},{"ruleId":"101","severity":1,"message":"116","line":1,"column":8,"nodeType":"103","messageId":"104","endLine":1,"endColumn":13},{"ruleId":"101","severity":1,"message":"116","line":1,"column":8,"nodeType":"103","messageId":"104","endLine":1,"endColumn":13},{"ruleId":"101","severity":1,"message":"102","line":4,"column":8,"nodeType":"103","messageId":"104","endLine":4,"endColumn":23},{"ruleId":"101","severity":1,"message":"105","line":5,"column":8,"nodeType":"103","messageId":"104","endLine":5,"endColumn":21},{"ruleId":"101","severity":1,"message":"116","line":1,"column":8,"nodeType":"103","messageId":"104","endLine":1,"endColumn":13},{"ruleId":"101","severity":1,"message":"102","line":2,"column":8,"nodeType":"103","messageId":"104","endLine":2,"endColumn":23},{"ruleId":"101","severity":1,"message":"120","line":22,"column":17,"nodeType":"103","messageId":"104","endLine":22,"endColumn":18},{"ruleId":"101","severity":1,"message":"121","line":23,"column":17,"nodeType":"103","messageId":"104","endLine":23,"endColumn":18},"no-native-reassign",["122"],"no-negated-in-lhs",["123"],"jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-unused-vars","'RandomGenerator' is defined but never used.","Identifier","unusedVar","'UtilFunctions' is defined but never used.","'style' is assigned a value but never used.","'PieceComponent' is defined but never used.","'loadTimer' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'turn' is assigned a value but never used.","'me' is assigned a value but never used.","'piece' is assigned a value but never used.","'React' is defined but never used.","no-redeclare","'i' is already defined.","redeclared","'x' is assigned a value but never used.","'y' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]