{"ast":null,"code":"import { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/game.component.jsx\";\nimport React, { Component } from 'react';\nimport mainService from '../services/main.service';\nimport Canvas from './canvas.component';\nimport PieceComponent from './piece.component';\n\nclass GameComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      gameId: JSON.parse(localStorage.getItem(\"auth\")).gameId,\n      me: JSON.parse(localStorage.getItem(\"auth\")).player,\n      inviteLink: \"http://localhost:3000/joingame/\" + JSON.parse(localStorage.getItem(\"auth\")).gameId,\n      //game\n      player1: {},\n      player2: {},\n      boardData: {},\n      // data from server\n      boardView: {},\n      // symbol, playertype\n      width: 16,\n      height: 16,\n      turn: \"Player1\",\n      // TODO: sth better than String switching?\n      round: 0,\n      //selection\n      selectedField: {},\n      possibleMoves: [],\n      //consts\n      squareSize: 25,\n      boardTopx: 25,\n      boardTopy: 25,\n      updateInterval: 1500\n    };\n    this.loadGameData();\n    this.loadBoard();\n    this.selectField = this.selectField.bind(this);\n    this.clickOnCanvas = this.clickOnCanvas.bind(this);\n    this.drawMethod = this.drawMethod.bind(this);\n    this.play = this.play.bind(this);\n    const loadTimer = setInterval(() => {\n      this.loadGameData();\n    }, loadInterval);\n  }\n\n  componentDidMount() {}\n\n  loadGameData() {\n    const {\n      gameId\n    } = this.state;\n    mainService.getGameData(gameId).then(res => {\n      this.setState({\n        player1: res.data.player1,\n        player2: res.data.player2,\n        turn: res.data.turn,\n        round: res.data.round\n      });\n    });\n  }\n\n  loadBoard() {\n    const {\n      gameId\n    } = this.state;\n    mainService.getBoard(gameId).then(res => {\n      let bv = res.data.board;\n      console.log(bv);\n\n      for (let i = 0; i < bv.length; i++) {\n        for (let j = 0; j < bv[0].length; j++) {\n          if (res.data.board[i][j] === null) {\n            bv[i][j] = {\n              symbol: \"\",\n              owner: \"\",\n              possibleMoves: []\n            };\n          } else {\n            bv[i][j] = {\n              symbol: bv[i][j].symbol,\n              owner: bv[i][j].owner,\n              possibleMoves: bv[i][j].possibleMoves\n            };\n          }\n        }\n      }\n\n      this.setState({\n        boardData: res.data,\n        boardView: bv,\n        width: bv[0].length,\n        height: bv.length\n      });\n    });\n  }\n\n  selectField(x, y) {\n    const {\n      boardView,\n      selectedField,\n      me,\n      turn,\n      possibleMoves\n    } = this.state;\n    const isPlayerTurn = me === turn;\n    console.log(me, \"=?\", turn);\n    const isEmptyField = boardView[y][x].symbol === \"\";\n    const sthSelected = JSON.stringify(selectedField) !== \"{}\";\n\n    if (sthSelected) {\n      const isAlreadySelected = selectedField.x === x && selectedField.y === y;\n      const isPossibleMove = possibleMoves.some(move => move.x === x && move.y === y);\n      const isOwnSelected = me == boardView[selectedField.y][selectedField.x].owner; // move,unselect, another select ?\n\n      if (isAlreadySelected) {\n        // unselect\n        console.log(\"unselect\");\n        this.setState({\n          possibleMoves: [],\n          selectedField: {}\n        });\n      } else if (isOwnSelected && isPossibleMove && isPlayerTurn) {\n        // move\n        console.log(\"move\");\n        const draw = {\n          fromPos: {\n            x: selectedField.x,\n            y: selectedField.y\n          },\n          toPos: {\n            x: x,\n            y: y\n          }\n        };\n        this.play(draw);\n      } else if (isEmptyField) {\n        // unselect\n        console.log(\"unselect2\");\n        this.setState({\n          possibleMoves: [],\n          selectedField: {}\n        });\n      } else {\n        // select new position\n        console.log(\"newpos\");\n        this.setState({\n          possibleMoves: boardView[y][x].possibleMoves,\n          selectedField: {\n            x: x,\n            y: y\n          }\n        });\n      }\n    } else {\n      if (!isEmptyField) {\n        // select new position\n        console.log(\"newPos2\");\n        this.setState({\n          possibleMoves: boardView[y][x].possibleMoves,\n          selectedField: {\n            x: x,\n            y: y\n          }\n        });\n      }\n    }\n  }\n\n  play(draw) {\n    const {\n      gameId,\n      turn\n    } = this.state;\n    mainService.play(gameId, draw).then(res => {\n      console.log(\"played\", turn);\n      const nextTurn = turn === \"Player1\" ? \"Player2\" : \"Player1\";\n      this.setState({\n        possibleMoves: [],\n        selectedField: {},\n        turn: nextTurn\n      });\n      this.loadGameData();\n      this.loadBoard();\n    });\n  }\n\n  clickOnCanvas(event) {\n    const {\n      squareSize,\n      boardTopy,\n      boardTopx\n    } = this.state;\n    const rect = event.target.getBoundingClientRect();\n    const x = event.clientX - rect.left - boardTopx;\n    const y = event.clientY - rect.top - boardTopy; //console.log(\"x: \" + x + \" y: \" + y);\n\n    this.selectField((x - x % squareSize) / squareSize, (y - y % squareSize) / squareSize);\n  }\n\n  drawMethod() {\n    const {\n      width,\n      height,\n      squareSize,\n      boardView,\n      possibleMoves,\n      boardTopy,\n      boardTopx,\n      selectedField,\n      me\n    } = this.state;\n    var ctx = null;\n\n    const draw = (ctx, frameCount) => {\n      if (boardView) {\n        ctx.canvas.width = squareSize * (width + 1);\n        ctx.canvas.height = squareSize * (height + 1); //draw board\n\n        for (let i = 0; i < width; i++) {\n          for (let j = 0; j < height; j++) {\n            ctx.fillStyle = (i + j) % 2 == 0 ? \"lightgray\" : \"gray\";\n            let xOffset = boardTopx + j * squareSize;\n            let yOffset = boardTopy + i * squareSize;\n            ctx.fillRect(xOffset, yOffset, squareSize, squareSize); //                ctx.fillRect(Math.sin(i*0.2)*xOffset, Math.sin(j*frameCount*0.001)*yOffset, squareSize, squareSize);\n          }\n        }\n\n        if (JSON.stringify(selectedField) !== \"{}\") {\n          // draw moves\n          ctx.globalAlpha = 0.45;\n          ctx.fillStyle = me === boardView[selectedField.y][selectedField.x].owner ? \"lightgreen\" : \"red\";\n\n          for (let k = 0; k < possibleMoves.length; k++) {\n            let xOffset = boardTopx + possibleMoves[k].x * squareSize;\n            let yOffset = boardTopy + possibleMoves[k].y * squareSize;\n            ctx.fillRect(xOffset, yOffset, squareSize, squareSize);\n          } //draw selected\n\n\n          ctx.fillStyle = me === boardView[selectedField.y][selectedField.x].owner ? \"green\" : \"darkred\";\n          ctx.fillRect(boardTopx + selectedField.x * squareSize, boardTopy + selectedField.y * squareSize, squareSize, squareSize);\n          ctx.globalAlpha = 1;\n        } // draw pieces\n\n\n        if (boardView[0]) {\n          ctx.fillStyle = \"black\";\n          ctx.font = \"20px Arial\";\n\n          for (let i = 0; i < width; i++) {\n            for (let j = 0; j < height; j++) {\n              if (boardView[j][i].symbol !== \"\") {\n                let symbol = boardView[j][i].owner === \"Player1\" ? \"♖\" : \"♜\";\n                let xOffset = boardTopx + (i + 0.12) * squareSize;\n                let yOffset = boardTopy + (j + 0.8) * squareSize;\n                ctx.fillText(symbol, xOffset, yOffset);\n              }\n            }\n          }\n        } // draw the border around the chessboard\n\n\n        ctx.strokeStyle = \"black\";\n        ctx.strokeRect(boardTopx, boardTopy, squareSize * width, squareSize * height);\n      }\n    };\n\n    return draw;\n  }\n\n  render() {\n    const {\n      inviteLink,\n      player1,\n      player2,\n      boardView,\n      selectedField,\n      turn,\n      round\n    } = this.state;\n    var piece = \"\";\n\n    if (boardView[0] && selectedField.x) {\n      piece = boardView[selectedField.y][selectedField.x]; //console.log(piece);\n    } // TODO: aufteilen in GameData und PieceData ?\n\n\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [inviteLink, /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"here is the Game: Player1: \", player1 && player1.name, \" \", player2 && /*#__PURE__*/_jsxDEV(_Fragment, {\n          children: [\"Player2: \", player2.name]\n        }, void 0, true), \" next:\", turn, \" \", \" round:\", round]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 238,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Canvas, {\n        draw: this.drawMethod(),\n        onClick: this.clickOnCanvas\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 241,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 236,\n      columnNumber: 13\n    }, this);\n  }\n\n}\n\nexport default GameComponent;","map":{"version":3,"sources":["/home/ich/MEGA/Entwicklung/FreeChess/repo/FreeChessRepo/FreeChess/FE/src/components/game.component.jsx"],"names":["React","Component","mainService","Canvas","PieceComponent","GameComponent","constructor","props","state","gameId","JSON","parse","localStorage","getItem","me","player","inviteLink","player1","player2","boardData","boardView","width","height","turn","round","selectedField","possibleMoves","squareSize","boardTopx","boardTopy","updateInterval","loadGameData","loadBoard","selectField","bind","clickOnCanvas","drawMethod","play","loadTimer","setInterval","loadInterval","componentDidMount","getGameData","then","res","setState","data","getBoard","bv","board","console","log","i","length","j","symbol","owner","x","y","isPlayerTurn","isEmptyField","sthSelected","stringify","isAlreadySelected","isPossibleMove","some","move","isOwnSelected","draw","fromPos","toPos","nextTurn","event","rect","target","getBoundingClientRect","clientX","left","clientY","top","ctx","frameCount","canvas","fillStyle","xOffset","yOffset","fillRect","globalAlpha","k","font","fillText","strokeStyle","strokeRect","render","piece","name"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport mainService from '../services/main.service';\nimport Canvas from './canvas.component';\nimport PieceComponent from './piece.component';\n\nclass GameComponent extends Component {\n    \n\n    \n    constructor(props) {\n        super(props)\n        this.state = {\n            gameId: JSON.parse(localStorage.getItem(\"auth\")).gameId,\n            me:JSON.parse(localStorage.getItem(\"auth\")).player,\n            inviteLink: \"http://localhost:3000/joingame/\" + JSON.parse(localStorage.getItem(\"auth\")).gameId,\n            \n            //game\n            player1: {},\n            player2: {},\n            boardData: {}, // data from server\n            boardView: {}, // symbol, playertype\n            width:16,\n            height:16,\n            turn:\"Player1\",// TODO: sth better than String switching?\n            round:0,\n\n            //selection\n            selectedField:{},\n            possibleMoves:[],\n\n            //consts\n            squareSize: 25,\n            boardTopx :25,\n            boardTopy : 25,\n            updateInterval: 1500\n        }\n        this.loadGameData();\n        this.loadBoard();\n        this.selectField = this.selectField.bind(this);\n        this.clickOnCanvas = this.clickOnCanvas.bind(this);\n        this.drawMethod = this.drawMethod.bind(this);\n        this.play = this.play.bind(this);\n\n        const loadTimer = setInterval(() => {\n            this.loadGameData();\n        }, loadInterval);\n    }\n\ncomponentDidMount(){\n\n}\n\n    loadGameData() {\n        const { gameId } = this.state;\n        mainService.getGameData(gameId).then((res) => {\n            this.setState({ player1: res.data.player1, player2: res.data.player2,turn:res.data.turn,round:res.data.round });\n        });\n    }\n\n    \n\n    loadBoard(){\n        const { gameId } = this.state;\n        mainService.getBoard(gameId).then((res) => {\n            let bv=res.data.board;\n            console.log(bv);\n            for (let i = 0; i < bv.length; i++) {\n                for (let j = 0; j < bv[0].length; j++) {\n                    if(res.data.board[i][j]===null){\n                        bv[i][j]={\n                            symbol: \"\",\n                            owner: \"\",\n                            possibleMoves: []};\n                    } else {\n                        bv[i][j]={\n                        symbol: bv[i][j].symbol,\n                        owner: bv[i][j].owner,\n                        possibleMoves: bv[i][j].possibleMoves};\n                    }\n                }\n            }\n            this.setState({ boardData:res.data,boardView:bv,width:bv[0].length,height:bv.length});\n\n        });\n    }\n\n    selectField(x,y){\n        const {boardView,selectedField,me,turn,possibleMoves} =this.state;\n        const isPlayerTurn = me === turn;\n        console.log(me,\"=?\",turn);\n        const isEmptyField = boardView[y][x].symbol===\"\";\n        const sthSelected = JSON.stringify(selectedField)!==\"{}\";\n\n        if(sthSelected){\n            const isAlreadySelected = selectedField.x===x && selectedField.y===y;\n            const isPossibleMove = possibleMoves.some(move => move.x === x && move.y===y);\n            const isOwnSelected = me==boardView[selectedField.y][selectedField.x].owner;\n\n            // move,unselect, another select ?\n\n            if(isAlreadySelected){\n                // unselect\n                console.log(\"unselect\");\n                this.setState({possibleMoves:[],\n                selectedField:{}});\n            } else if(isOwnSelected && isPossibleMove && isPlayerTurn){\n                // move\n                console.log(\"move\");\n                const draw = {fromPos:{x:selectedField.x,y:selectedField.y},toPos:{x:x,y:y}}\n                this.play(draw);\n            } else if(isEmptyField){\n                // unselect\n                console.log(\"unselect2\");\n                this.setState({possibleMoves:[],\n                selectedField:{}});\n            } else {\n                // select new position\n                console.log(\"newpos\");\n                this.setState({possibleMoves:boardView[y][x].possibleMoves,\n                selectedField:{x:x,y:y}});\n            }\n        } else {\n            if(!isEmptyField){\n                // select new position\n                console.log(\"newPos2\");\n                this.setState({possibleMoves:boardView[y][x].possibleMoves,\n                    selectedField:{x:x,y:y}});\n            }\n        }\n    }\n\n    play(draw){\n        const {gameId,turn} = this.state;\n        mainService.play(gameId,draw).then((res) => {\n            console.log(\"played\",turn);\n            const nextTurn = (turn===\"Player1\")?\"Player2\":\"Player1\";\n            this.setState({possibleMoves:[],\n                selectedField:{},\n                turn:nextTurn});\n                \n                this.loadGameData();\n            this.loadBoard();\n        });\n    }\n\n\n\n\n    clickOnCanvas(event){\n        const {squareSize,boardTopy,boardTopx} = this.state;\n        const rect = event.target.getBoundingClientRect();\n        const x = event.clientX - rect.left-boardTopx;\n        const y = event.clientY - rect.top- boardTopy;\n        //console.log(\"x: \" + x + \" y: \" + y);\n        this.selectField((x - x % squareSize)/(squareSize),(y - y % squareSize)/(squareSize));\n    }\n\n    drawMethod(){\n        const {width,height,squareSize,boardView,possibleMoves,boardTopy,boardTopx,selectedField,me} = this.state;\n        var ctx = null;\n\n        const draw = (ctx, frameCount) => {\n\n        if(boardView){\n    \n            ctx.canvas.width=squareSize*(width+1)\n            ctx.canvas.height=squareSize*(height+1)\n\n            //draw board\n            for(let i=0; i<width; i++) {\n              for(let j=0; j<height; j++) {\n                ctx.fillStyle = ((i+j)%2==0) ? \"lightgray\":\"gray\";\n                let xOffset = boardTopx + j*squareSize;\n                let yOffset = boardTopy + i*squareSize;\n                ctx.fillRect(xOffset, yOffset, squareSize, squareSize);\n//                ctx.fillRect(Math.sin(i*0.2)*xOffset, Math.sin(j*frameCount*0.001)*yOffset, squareSize, squareSize);\n              }\n            }\n            if(JSON.stringify(selectedField)!==\"{}\"){\n            // draw moves\n            ctx.globalAlpha = 0.45;\n            ctx.fillStyle=(me===boardView[selectedField.y][selectedField.x].owner)?\"lightgreen\":\"red\";\n            for(let k=0; k<possibleMoves.length; k++) {\n                let xOffset = boardTopx + possibleMoves[k].x*squareSize;\n                let yOffset = boardTopy + possibleMoves[k].y*squareSize;\n                \n                ctx.fillRect(xOffset, yOffset, squareSize, squareSize);\n            }\n\n            //draw selected\n            ctx.fillStyle=(me===boardView[selectedField.y][selectedField.x].owner)?\"green\":\"darkred\";\n            ctx.fillRect(boardTopx + selectedField.x*squareSize, boardTopy + selectedField.y*squareSize, squareSize, squareSize);\n            ctx.globalAlpha = 1;\n        }\n\n            // draw pieces\n            if(boardView[0]){\n            ctx.fillStyle = \"black\";\n            ctx.font = \"20px Arial\";\n            for(let i=0; i<width; i++) {\n                for(let j=0; j<height; j++) {\n                    if(boardView[j][i].symbol!==\"\"){\n                        let symbol = (boardView[j][i].owner===\"Player1\")?\"♖\":\"♜\";\n                        let xOffset = boardTopx + (i+0.12)*squareSize;\n                        let yOffset = boardTopy + (j+0.8)*squareSize;\n                        ctx.fillText(symbol,xOffset,yOffset);\n                    }\n                }\n            }\n        }\n\n            // draw the border around the chessboard\n            ctx.strokeStyle = \"black\";\n            ctx.strokeRect(boardTopx, boardTopy, squareSize*width, squareSize*height)\n    \n    }\n    }\n    return draw;\n    }\n\n\n\n\n    \n    render() {\n        const { inviteLink, player1, player2, boardView,selectedField ,turn,round} = this.state;\n        var piece= \"\";\n        if(boardView[0] && selectedField.x){\n            piece = boardView[selectedField.y][selectedField.x];\n            //console.log(piece);\n        }\n\n        // TODO: aufteilen in GameData und PieceData ?\n\n        return (\n            <div>\n                {inviteLink}\n                <div>\n                here is the Game: Player1: {player1 && player1.name} {player2 && <>Player2: {player2.name}</>}{\" next:\"}{turn} {\" round:\"}{round}\n                </div>\n            <Canvas draw={this.drawMethod()} onClick={this.clickOnCanvas} />\n           {/* <div>{piece.symbol} {\" \"}{piece.owner}</div>*/}\n            </div>\n        )\n    }\n}\n\nexport default GameComponent"]},"metadata":{},"sourceType":"module"}